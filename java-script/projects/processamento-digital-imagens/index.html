<!DOCTYPE html>
<html>

    <head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Processamento Digital de Imagens - Dudevictor GitHub IO</title>
    <meta name="description" content="Aspirante a Engenheiro de Computação e formado em Ciências e Tecnologia pela UFRN. Desenvolvedor Java Web na Logique Sistemas.">

    <link rel="profile" href="http://gmpg.org/xfn/11"/>
    <link rel="stylesheet" href="/css/bootstrap.min.css">
    <link rel="stylesheet" href="/css/font-awesome.css">
    <link rel="stylesheet" type="text/css" media="all" href="/css/style.css"/>
    <link rel="stylesheet" type="text/css" media="all" href="/css/jquery.mmenu.all.css"/>
    <link rel="stylesheet" href="/css/androidstudio.css">
    <link rel="stylesheet" href="/css/toc.css">

    <!-- Favicons generated at http://realfavicongenerator.net/ -->
    <link rel="apple-touch-icon" sizes="57x57" href="/favicons/apple-touch-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="/favicons/apple-touch-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/favicons/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/favicons/apple-touch-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/favicons/apple-touch-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/favicons/apple-touch-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/favicons/apple-touch-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/favicons/apple-touch-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/favicons/apple-touch-icon-180x180.png">
    <link rel="icon" type="image/png" href="/favicons/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="/favicons/android-chrome-192x192.png" sizes="192x192">
    <link rel="icon" type="image/png" href="/favicons/favicon-96x96.png" sizes="96x96">
    <link rel="icon" type="image/png" href="/favicons/favicon-16x16.png" sizes="16x16">
    <link rel="manifest" href="/favicons/manifest.json">
    <link rel="shortcut icon" href="/favicons/favicon.ico">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-TileImage" content="/favicons/mstile-144x144.png">
    <meta name="msapplication-config" content="/favicons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <meta http-equiv="Content-Language" content="pt-BR">

    <link rel="alternate"
          hreflang="pt-BR"
          href="http://dudevictor.github.io"/>
    
    
    
    
    <link rel="alternate"
          hreflang="en"
          href="http://dudevictor.github.io/en"/>
    

    
    <!-- Go to www.addthis.com/dashboard to customize your tools -->
    <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-56d8c061351eac81"></script>
    

    
    <script type="text/javascript">
        var _gaq = _gaq || [];
        _gaq.push(['_setAccount', 'UA-74364829-1']);
        _gaq.push(['_trackPageview']);
        (function () {
            var ga = document.createElement('script');
            ga.type = 'text/javascript';
            ga.async = true;
            ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';

            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(ga, s);
        })();
    </script>
    
</head>


    <body>

    <nav id="my-menu">
  <div>
    <ul class="pages">
      <li><a href=" /
                                                    "><i class="fa fa-home"></i> Início</a></li>
      <li>
        <span><i class="fa fa-archive"></i> Todos os Projetos</span>
        <ul>
        
          <li><a href=" /projects/processamento-digital-imagens/
                                                    "><i class="fa fa-picture-o"></i>
            Processamento Digital de Imagens</a></li>
        
          <li><a href=" /projects/programacao-concorrente/
                                                    "><i class="fa fa-laptop"></i>
            Programação Concorrente e Distribuída</a></li>
        
          <li><a href=" /projects/controle-inteligente/
                                                    "><i class="fa fa-globe"></i>
            Controle Inteligente - A* Algorithm</a></li>
        
        </ul>
      </li>
      <li><a href=" 
                                                    /posts/"><i class="fa fa-file-text"></i> Todos os Artigos</a></li>
      <li><a href=" 
                                                    /search/"><i class="fa fa-search"></i> Pesquisar</a></li>
    </ul>

    <p class="links">
  
  <a href="https://br.linkedin.com/in/jvictoralves" target="_new"><i class="fa fa-linkedin"></i></a>
  <a href="https://github.com/dudevictor" target="_new"><i class="fa fa-github-alt"></i></a>
  <a href="https://fb.com/dudevictor" target="_new"><i class="fa fa-facebook"></i></a>
  <a href="https://plus.google.com/103774151163089217676" target="_new"><i class="fa fa-google-plus"></i></a>
  <a href="http://stackoverflow.com/users/2327056/jose-victor?tab=profile" target="_new"><i class="fa fa-stack-overflow"></i></a>
</p>

  </div>
</nav>
<div class="menu-button" href="#menu"><i class="fa fa-bars"></i></div>


    <div class="page-content">
      <div class="wrap">
      <div class="container-fluid single">
  <div class="row">

    <div itemscope itemtype="http://schema.org/Article" class="col-md-12 project">
      
      <div class="thumb">
        <i class="fa fa-picture-o fa-4x"></i>
      </div>
      

      <h1 class="header" itemprop="name">Processamento Digital de Imagens</h1>

      <div class="author">
        <small><i>
          
          por
          <span itemprop="author">
            
              <a rel="author" href="https://plus.google.com/103774151163089217676">
            
            <span itemprop="author" itemscope itemtype="http://schema.org/Person">
              <span itemprop="name">José Victor Alves de Souza</span>
            </span>
            
              </a>
            
          </span>
          
          em <span itemprop="datePublished" content="2014-08-28">03 de Março de 2016</span>
        </i></small>
      </div>

      <div class="read-time">
        <small>
          Prof. Agostinho Brito Júnior, Departamento de Engenharia de Computação, UFRN 2016.1
        </small>
      </div>

      <div class="anuncio-cabecalho">
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <!-- Cabeçalho Responsivo -->
    <ins class="adsbygoogle"
         style="display:block"
         data-ad-client="ca-pub-9976909752880073"
         data-ad-slot="1413881545"
         data-ad-format="auto"></ins>
    <script>
        (adsbygoogle = window.adsbygoogle || []).push({});
    </script>
    
</div>

      <div class="content-panel content">
        <span itemprop="articleBody"><div id="toc-container">
  <table class="toc" id="toc">
    <tbody>
      <tr>
        <td>
          <div id="toctitle">
            <h2>Conteúdo</h2>
          </div>
          <ul>
            <li class="toc_level-1 toc_section-1">
              <a href="#topico-1-1"><span class="tocnumber">1.</span> <span class="toctext">Introdução</span></a>
            </li>
            <li class="toc_level-1 toc_section-2">
              <a href="#topico-1-2"><span class="tocnumber">2.</span> <span class="toctext">Primeira Unidade</span></a>
              <ul>
                <li class="toc_level-2 toc_section-3">
                  <a href="#topico-1-2-1"><span class="tocnumber">2.1.</span> <span class="toctext">Manipulando pixels em uma imagem</span></a>
                </li>
                <li class="toc_level-2 toc_section-4">
                  <a href="#topico-1-2-2"><span class="tocnumber">2.2.</span> <span class="toctext">Preenchendo Regiões com OpenCV</span></a>
                </li>
                <li class="toc_level-2 toc_section-5">
                  <a href="#topico-1-2-3"><span class="tocnumber">2.3.</span> <span class="toctext">Manipulação de Histogramas</span></a>
                </li>
                <li class="toc_level-2 toc_section-6">
                  <a href="#topico-1-2-4"><span class="tocnumber">2.4.</span> <span class="toctext">Filtragem no domínio espacial I</span></a>
                </li>
                <li class="toc_level-2 toc_section-7">
                  <a href="#topico-1-2-5"><span class="tocnumber">2.5.</span> <span class="toctext">Filtragem no domínio espacial II</span></a>
                </li>
              </ul>
            </li>
            <li class="toc_level-1 toc_section-8">
              <a href="#topico-1-8"><span class="tocnumber">3.</span> <span class="toctext">Segunda Unidade</span></a>
              <ul>
                <li class="toc_level-2 toc_section-9">
                  <a href="#topico-1-8-1"><span class="tocnumber">3.1.</span> <span class="toctext">Filtragem no Domínio da Frequência</span></a>
                </li>
                <li class="toc_level-2 toc_section-10">
                  <a href="#topico-1-8-2"><span class="tocnumber">3.2.</span> <span class="toctext">Canny e a arte do pontilhismo</span></a>
                </li>
              </ul>
            </li>
          </ul>
        </td>
      </tr>
    </tbody>
  </table>
</div><h3 id="topico-1-1">Introdução</h3>

<p>Esta página tem como objetivo apresentar os resultados dos exercícios da disciplina de Processamento Digital de Imagens
lecionada pelo professor <a href="http://agostinhobritojr.github.io/">Agostinho Brito Júnior</a> no semestre 2016.1. Estes exercícios podem ser encontrados <a href="http://agostinhobritojr.github.io/tutoriais/pdi/">aqui</a>.
Para compilar os códigos apresentados neste tópico pode-se utilizar <a href="/assets/pdi/Makefile">este arquivo</a>.</p>

<p>Esta página estará sendo atualizada conforme a disciplina for sendo encaminhada.</p>

<h3 id="topico-1-2">Primeira Unidade</h3>

<h4 id="topico-1-2-1">Manipulando pixels em uma imagem</h4>

<p>Inicialmente é solicitado a implementação de um programa que exiba o negativo de uma imagem a partir de dois pontos
lidos <code>P1</code>e <code>P2</code>. Os pontos são lidos via terminal na ordem <code>P1.x</code>, <code>P1.y</code>, <code>P2.x</code> e <code>P2.y</code>. Para aplicar o efeito
 de negativo, basta inverter cada uma das escalas das componentes RGB em cada um dos pixels
 da região especificada. Para inverter é só cálcular: <code>255 - VALOR_ESCALA</code>.</p>

<p>O código do <a href="/assets/codes-copyright/regions.cpp">regions.cpp</a> pode ser visto a seguir:</p>
<div class="highlight">
  <pre>
    <code class="language-" data-lang="">#include &lt;iostream&gt;
#include &lt;cv.h&gt;
#include &lt;highgui.h&gt;

using namespace cv;
using namespace std;

void usage(int qtdArgs, char** args);

int main(int qtdArg, char** args){
    usage(qtdArg, args);
    Mat image;

    image= imread(args[1], CV_LOAD_IMAGE_COLOR);

    int p1x = atoi(args[2]);
    int p1y = atoi(args[3]);
    int p2x = atoi(args[4]);
    int p2y = atoi(args[5]);

    if(!image.data)
        cout &lt;&lt; "nao abriu a imagem" &lt;&lt; endl;

    namedWindow("janela", WINDOW_AUTOSIZE);

    for(int i=p1x;i&lt; p2x;i++) {
        for(int j=p1y; j&lt; p2y;j++){
            Vec3b valor = image.at&lt;Vec3b&gt;(i,j);
            valor[0] = 255 - valor[0];
            valor[1] = 255 - valor[1];
            valor[2] = 255 - valor[2];
            image.at&lt;Vec3b&gt;(i,j) = valor;
        }
    }
    imshow("janela", image);
    waitKey();
    return 0;
}
void usage(int qtdArgs, char** args) {
    if (qtdArgs &lt; 6) {
        printf("Uso: ./regions &lt;nome_arquivo&gt; X1 Y1 X2 Y2\n");
        exit(0);
    }
}
</code>
  </pre>
</div>
<p>Para executar o programa basta realizar os seguintes comandos no terminal:</p>
<div class="highlight">
  <pre>
    <code class="language-" data-lang="">    make regions
    ./regions wallpaper.jpg 100 100 350 650
</code>
  </pre>
</div>
<p>O resultado está apresentado a seguir:</p>

<p>
  <img src="/assets/pdi/resultadoRegions.png" alt="ResultadoRegions.cpp" />
</p>

<p>Em seguida, é solicitado que implemente-se um algoritmo em OpenCV que troque regiões de uma imagem como
um quebra-cabeça, utilizando alguns construtores da classe <code>Mat</code>.</p>

<p>O <a href="/assets/codes-copyright/trocaregioes.cpp">código</a> implementado está apresentado a seguir:</p>
<div class="highlight">
  <pre>
    <code class="language-" data-lang="">#include &lt;iostream&gt;
#include &lt;cv.h&gt;
#include &lt;highgui.h&gt;

using namespace cv;
using namespace std;

void usage(int qtdArgs, char** args);
int main(int qtdArg, char** args) {
    usage(qtdArg, args);
    Mat image;

    image= imread(args[1], CV_LOAD_IMAGE_COLOR);
    int width = image.size().width;
    int height = image.size().height;

    //Este construtor mapeia uma região retangular definido pelo Rect(...) de uma imagem em uma nova instância de Mat
    Mat A(image, Rect(0, 0, width/2, height/2));
    Mat B(image, Rect(width/2, 0, width/2, height/2));
    Mat C(image, Rect(0, height/2, width/2, height/2));
    Mat D(image, Rect(width/2, height/2, width/2, height/2));

    //Cria uma matrix de zeros de mesmo tamanho da original
    Mat saida = Mat::zeros(image.size(), image.type());
    Mat aux;

    //Utiliza uma variavel auxiliar para mapear a nova região da matriz de saída 
    aux = saida.colRange(0, width/2).rowRange(0, height/2);
    //Copia o conteúdo em D na região mapeada pela variável auxiliar
    D.clone().copyTo(aux);

    aux = saida.colRange(width/2, width).rowRange(0, height/2);
    C.copyTo(aux);

    aux = saida.colRange(0, width/2).rowRange(height/2, height);
    B.copyTo(aux);

    aux = saida.colRange(width/2, width).rowRange(height/2, height);
    A.copyTo(aux);

    if(!image.data)
        cout &lt;&lt; "nao abriu a imagem" &lt;&lt; endl;

    namedWindow("janela", WINDOW_AUTOSIZE);
    imshow("janela", saida);
    waitKey();
    return 0;

}
</code>
  </pre>
</div>
<p>O programa pou ser executado da seguinte forma: <code>./trocaregioes &lt;nome_arquivo&gt;</code>. O resultado 
pode ser visto a seguir:</p>

<p>
  <img src="/assets/pdi/resultadoTrocaRegioes.png" alt="Resultado Troca Regiões" />
</p>

<h4 id="topico-1-2-2">Preenchendo Regiões com OpenCV</h4>

<p>No programa <a href="/assets/codes-copyright/labeling.cpp">labeling.cpp</a> fornecido, cada objeto encontrado é rotulado com um valor no tom de cinza que varia entre <code>0</code> e <code>255</code>.
Portanto, quando há mais do que 255 objetos na cena, a rotulação fica comprometida pois não mais mais tons de cinza
que possam ser utilizados para rotular o restante dos objetos.</p>

<p>Uma possível solução para este problema seria resetar a contagem da variável <code>nobjects</code>, utilizando a função módulo.
O código modificado está apresentado a seguir:</p>
<div class="highlight">
  <pre>
    <code class="language-" data-lang="">/* ... Código antes */
  nobjects=0;
  for(int i=0; i&lt;height; i++){
    for(int j=0; j&lt;width; j++){
      if(image.at&lt;uchar&gt;(i,j) == 255){
        // achou um objeto
        nobjects++;
        p.x=j;
        p.y=i;
        floodFill(image,p,nobjects % 255);
      }
    }
  }
/* ... Código Depois */
</code>
  </pre>
</div>
<p>Dessa forma, quando o valor de <code>nobjects</code> passa a ser maior ou igual a 255, a escala de cinza passa a ser "zerada".</p>

<p>O próximo passo é implementar uma solução que realize a contagem de objetos que possuem buracos
 e de objetos não possuem buracos, desconsiderando aqueles elementos que tocam a borda da imagem.
 Para isso, foi utilizado a seguinte imagem como teste:
 <img src="/assets/pdi/bolhas2.png" alt="Imagem binária de bolhas" /></p>

<p>O primeiro passo a se fazer é remover todas os elementos que tocam a borda. Para isso, aplica-se o tom de 
 cinza branco (255) a todos os pixels da borda e então, realiza-se um <em>floodfill</em> para o tom de cinza <code>0</code> igual ao do fundo da imagem.
 Para diferenciar o fundo da imagem de um buraco, aplica-se novamente o <em>floodfill</em>; dessa vez rotulando com tom de cinza <code>1</code>
 que no código abaixo, foi chamado de "BACKGROUND".
 Depois disso, realiza-se uma contagem total de bolhas, procurando por um tom de cinza <code>255</code> e rotulando todos os elementos encontrados
 inicialmente como "SEM BOLHAS".</p>

<p>Por fim, realiza-se a rotulagem por aqueles elementos que possuem bolhas. Para fazer isso, percorre-se a matriz da imagem,
  e sempre que for encontrado um pixel com rótulo SEM BOLHA ou COM BOLHA, armazena-se as coordenadas x e y desse elemento na variável <code>p</code>.
  O laço é continuado até encontrar um pixel de tom de cinza <code>0</code> (caso em que foi encontrada uma bolha), e nessa situação aplica-se o <em>floodfill</em> 
  no último elemento <code>p</code> encontrado, rotulando este último agora como "COM BOLHA", aproveita-se também e rotula-se o buraco
  encontrado como "COM_BOLHA" (poderia ser outro rótulo) para que esta bolha não seja encontrada novamente. Se o elemento <code>p</code> já tiver sido rotulado
  como "COM_BOLHA" não é necessário refazer o <em>floodfill</em>.</p>

<p>O código completo em <code>C++</code> é apresentado abaixo. O código também pode ser baixado por <a href="/assets/codes-copyright/labeling_contagem.cpp">aqui</a>.</p>
<div class="highlight">
  <pre>
    <code class="language-" data-lang="">#include &lt;iostream&gt;
#include &lt;opencv2/opencv.hpp&gt;

using namespace cv;

int main(int argc, char** argv){
  Mat image, mask;
  int width, height;
  int nobjects;
  int BRANCO = 255;
  int PRETO = 0;
  int BACKGROUND = 1;
  int COM_BOLHA = 67;
  int SEM_BOLHA = 196;
  CvPoint p;
  p.x = 0;
  p.y = 0;
  image = imread(argv[1],CV_LOAD_IMAGE_GRAYSCALE);

  if(!image.data){
    std::cout &lt;&lt; "imagem nao carregou corretamente\n";
    return(-1);
  }
  imshow("imageOriginal", image);
  width=image.size().width;
  height=image.size().height;

  //Aplica 255 em todos os pontos na borda da
  // imagem e aplica-se o floodfill para remover os elementos que tocam as bordas
  for (int i = 0; i &lt; width; i++) {
    image.at&lt;uchar&gt;(i, height -1) = BRANCO;
    image.at&lt;uchar&gt;(i, 0) = BRANCO;
  }

  for (int i = 0; i &lt; height; i++) {
    image.at&lt;uchar&gt;(0, i) = BRANCO;
    image.at&lt;uchar&gt;(width -1, i) = BRANCO;
  }
  //Aplica-se o floodfill no ponto (0, 0) removendo todos os elementos da borda
  floodFill(image, p, PRETO);

  //Aplica-se o floodfill em todo o background da imagem
  floodFill(image, p, BACKGROUND);


  //Procurando por Elementos, julgando inicialmente que nenhum tem bolhas
  int qtdTotal = 0;
  for (int i = 0; i &lt; height; i++) {
    for (int j = 0; j &lt; width; j++) {
      if (image.at&lt;uchar&gt;(i, j) == BRANCO) {
        p.x = j;
        p.y = i;
        floodFill(image, p, SEM_BOLHA);
        qtdTotal++;
      }
    }
  }

  //Procurando por Elementos que possuem bolhas
  int qtdComBolhas = 0;
  for (int i = 0; i &lt; height; i++) {
    for (int j = 0; j &lt; width; j++) {
      //Armazene a posição do elemento encontrado, independente se for rotulado com bolha ou sem bolha
      if (image.at&lt;uchar&gt;(i,j) == SEM_BOLHA || image.at&lt;uchar&gt;(i,j) == COM_BOLHA) {
        p.x = j;
        p.y = i;
      } else if (image.at&lt;uchar&gt;(i,j) == PRETO) {
        //Caso for encontrado um buraco (rotulo PRETO), rotule o ultimo elemento encontrado como "COM_BOLHA",
         //se ele não já tiver sido rotulado como um
        if (image.at&lt;uchar&gt;(p.y, p.x) == SEM_BOLHA) {
          floodFill(image, p, COM_BOLHA);
          qtdComBolhas++;
        }
        //Rotule o buraco encontrado como COM_BOLHA (poderia ser um rótulo diferente também)
        p.x = j;
        p.y = i;
        floodFill(image, p, COM_BOLHA);
      }
    }
  }

  imshow("image", image);
  imwrite("labeling.png", image);
  printf("Quantidade de elementos sem bolhas: %d, com bolhas: %d\n", qtdTotal - qtdComBolhas, qtdComBolhas);
  waitKey();
  return 0;
}
</code>
  </pre>
</div>
<p>O resultado está apresentado na imagem abaixo:
 <img src="/assets/pdi/resultadoBolhas.png" alt="Resultado Contagem por Labeling" />
 <img src="/assets/pdi/resultadoLabelingTerminal.png" alt="Resultado Contagem por Labeling no Terminal" /></p>

<h4 id="topico-1-2-3">Manipulação de Histogramas</h4>

<p>O primeiro exercício deste tópico solicita que se implemente um programa chamado <code>equalize.cpp</code> que realize
a equalização de histograma utilizando as funções do OpenCV.</p>

<p>O processo de equalização de imagens consiste em mapear uma determinada distribuição de um histograma em um outro, sendo
que neste útlimo, a distribuição ficará mais uniformente distribuída. Como resultado, nota-se uma melhor distribuição 
 do nível de intensidade (brilho) das cores do que na imagem original.</p>

<p>Um histograma de uma imagem nada mais é do que um gráfico que diz a quantidade de pixels que pertencem ao mesmo nível de brilho
 numa faixa de 0 (mais escuro) a 255 (mais claro). A seguir tem-se um exemplo de uma imagem e seu histograma:
 <img src="/assets/pdi/rio_gray.jpg" alt="Rio GrayScale" />
 <img src="/assets/pdi/histograma.png" alt="Histograma" /></p>

<p>É fácil perceber que para fazer a equalização da imagem acima é fácil pois ela possui somente um canal de cor
por ser em <em>Grayscale</em>. No entanto, quando se trata de uma imagem colorida esse procedimento não é tão trivial, pois
não faz sentido aplicar o processo de equalização diretamente no histograma de uma imagem RGB. A forma encontrada de aplicar
 a equalização neste caso foi converter a imagem em RGB para o formato <a href="https://en.wikipedia.org/wiki/YCbCr">YCrCb</a>, já que esse padrão separa a intensidade luminosa
 dos outros componentes de cor.</p>

<p>O código da solução desse exercício é apresentado abaixo:</p>
<div class="highlight">
  <pre>
    <code class="language-" data-lang=""> #include &lt;iostream&gt;
 #include &lt;opencv2/opencv.hpp&gt;

 using namespace cv;
 using namespace std;

 int main(int argc, char** argv){
     Mat image;
     VideoCapture cap;
     vector&lt;Mat&gt; channels;

     image= imread(argv[1], CV_LOAD_IMAGE_COLOR);
     imshow("original", image);

     Mat imagemYCrCb;
     //Converte a imagem RGB para o padrão YCrCb
     cvtColor(image, imagemYCrCb, CV_BGR2YCrCb);

     split(imagemYCrCb, channels);
     //Aplica-se a equalização no primeiro canal Y (intensidade luminosa)
     equalizeHist(channels[0], channels[0]);
     merge(channels, imagemYCrCb);
     Mat result;
     cvtColor(imagemYCrCb, result, CV_YCrCb2BGR);
     namedWindow("image", WINDOW_AUTOSIZE);
     imshow("image", result);
     waitKey();
     return 0;
 }
</code>
  </pre>
</div>
<p>O código também pode ser baixado <a href="/assets/codes-copyright/equalize.cpp">aqui</a>. Segue o resultado do algoritmo:</p>

<p>Sem Equalização:
<img src="/assets/pdi/rio.jpg" alt="Rio" /></p>

<p>Com Equalização:
<img src="/assets/pdi/resultado_histograma.png" alt="Resultado Equalização" /></p>

<p>A segunda parte desse exercício, solicita que seja implementado o programa <code>motiondetector.cpp</code>. 
Este programa deve calcular o histograma das imagens captadas pela câmera e quando a diferença entre o
histograma atual e o anterior ultrapassar um determinado limiar, a aplicação deve acionar um aviso.</p>

<p>Nessa implementação, o aviso aparece como um círculo vermelho na parte superior esquerda da tela 
quando o limiar do histograma é ultrapassado. O limiar é indentificado no código do programa como sendo
a variável <code>tolerância</code>. Também foi adicionado no código a variável <code>COUNT_MAX</code> que expressa quantas 
 vezes consecutivas os histogramas captados devem ultrapassar o limiar para que o alarme efetivamente
 ocorra.</p>

<p>Para auxiliar a comparação entre dois histogramas, fez-se uso do método <a href="http://docs.opencv.org/2.4/doc/tutorials/imgproc/histograms/histogram_comparison/histogram_comparison.html">compareHist</a> do OpenCV.
Além das variáveis de histogramas que se deseja comparar, essa função recebe como parâmetro o método
 de comparação, que no OpenCV são 4:</p>

<ul>
<li>Correlação</li>
<li>Chi-Square</li>
<li>Interseção</li>
<li>Distância de Bhattacharyya</li>
</ul>

<p>No código foi adotado o método de correlação que retorna um valor entre 0 e 1 (menos correlacionado para o mais) e
com um valor de tolerância igual a <code>0.995</code>. O código implementado pode ser baixado <a href="/assets/codes-copyright/motiondetector.cpp">aqui</a> e o resultado
pode ser visto abaixo:</p>

<p>
  <img src="/assets/pdi/deteccao_movimento.png" alt="Detecção de Movimento com Histogramas" />
</p>

<p>Como resultado, nota-se que o programa dispara o alarme toda vez que há uma alteração no histograma da imagem captada.
Por exemplo, na imagem acima, toda vez que o livro era movido na frente da câmera, o alarme disparava. 
Para alterar a sensibilidade da detecção basta altera os parâmetros de <code>tolerância</code> e <code>COUNT_MAX</code> no código.</p>

<h4 id="topico-1-2-4">Filtragem no domínio espacial I</h4>

<p>Esse exercício, solicita que modifique o código fornecido <a href="/assets/pdi/filtroespacial.cpp">filtroespacial.cpp</a> para que seja adicionado
uma nova funcionalidade de aplicar o laplaciano do gaussiano nas imagens capturadas pela webcam.</p>

<p>O filtro gaussiano realiza a suavização das bordas da imagens, tornando a imagem menos nítida. Em contrapartida,
  esse filtro consegue amenizar o efeito do ruído apresentado na imagem. O código do <code>filtroespacial.cpp</code>
  foi modificado e foi adicionado a funcionaliade na tecla <code>b</code>. O código implementado pode ser baixado 
  <a href="/assets/codes-copyright/laplgauss.cpp">aqui</a> e o resulta da solução é apresentado a seguir:</p>

<p>Filtro do Laplaciano:
<img src="/assets/pdi/laplaciano_resultado.png" alt="Resultado da filtragem do Laplaciano" /></p>

<p>Filtro do Laplaciano do Gaussiano:
<img src="/assets/pdi/gaussiano_laplaciano_resultado.png" alt="Resultado da filtragem do Laplaciano do gaussiano" /></p>

<p>Nota-se que o filtro do gaussiano atenuou o ruído da imagem, facilitando a identificação das bordas com
o filtro laplaciano.</p>

<h4 id="topico-1-2-5">Filtragem no domínio espacial II</h4>

<p>Este exercício solicita que seja implementado o programa <code>tiltshift.cpp</code>. Este programa deve realizar a leitura
de uma imagem para que se aplique o efeito do <em>tiltshift</em>, disponibilizando na interface 3 funcionalidades:</p>

<ul>
<li>Ajuste da altura da região central que entrará em foco;</li>
<li>Ajuste para regular a força de decaimento da região borrada;</li>
<li>Ajuste para regular a posição vertical que entrará em foco;</li>
</ul>

<p>A implementação realizada inicialmente carrega a imagem em duas variáveis e aplica-se
o filtro da média consecutivas vezes em uma delas:</p>
<div class="highlight">
  <pre>
    <code class="language-" data-lang="">    image1 = imread("tilt/traffic_newyorkcity.jpg");
    height = image1.size().height;
    image2 = image1.clone();
    Mat aux, mask, mask1;
    float media[] = {1,1,1,
                     1,1,1,
                     1,1,1};

    mask = Mat(3, 3, CV_32F, media);
    scaleAdd(mask, 1/9.0, Mat::zeros(3,3,CV_32F), mask1);
    mask = mask1;
    image2.convertTo(aux, CV_32F);
    for (int i = 0; i &lt; deepMedia; i++) {
        filter2D(aux, aux, aux.depth(), mask, Point(1, 1), 0);
    }
    aux=abs(aux);
    aux.convertTo(image2, CV_8UC3);
</code>
  </pre>
</div>
<p>Para modelar a região de desfoque ao longo do eixo vertical da imagem, foi utilizado a seguinte função:</p>

<p>$$ \alpha(x) = \frac{1}{2} ( \tanh \frac{x-l1}{d}-tanh\frac{x-l2}{d} ) $$</p>

<p>A função implementada em C++ que monta a matriz alfa está apresentada a seguir:</p>
<div class="highlight">
  <pre>
    <code class="language-" data-lang="">void calcAlpha() {
int l1 = - tamanho_faixa/2;
    int l2 = -l1;
    alpha = Mat::zeros(image1.rows, image1.cols, CV_32F);
    beta = Mat::zeros(image1.rows, image1.cols, CV_32F);
    int i, j;
    for (i = 0; i &lt; alpha.rows; i++) {
        int x = i - (posicao_vertical + tamanho_faixa/2);
        float alphaValue = 0.5f * (tanh((x - l1)/decaimento) - tanh((x - l2)/decaimento));
        for (j = 0; j &lt; alpha.cols; j++) {
            alpha.at&lt;float&gt;(i, j) = alphaValue;
            beta.at&lt;float&gt;(i, j) = 1 - alphaValue;
        }
    }
    Mat auxA[] = {alpha, alpha, alpha};
    Mat auxB[] = {beta, beta, beta};
    merge(auxA, 3, alpha);
    merge(auxB, 3, beta);
    updateScene();
}
</code>
  </pre>
</div>
<p>Onde foi assumido que a variável <code>Mat alpha</code> irá ponderar a imagem original
e a variável <code>Mat beta</code>, que é calculada como sendo \(1 - \alpha\), 
ponderá a imagem borrada. Essa expressão é recalculada toda vez que há
alterações nos parâmetros da interface pelo usuário.</p>

<p>A imagem resultante com <em>TiltShift</em> é dada pela seguinte expressão:</p>

<p>$$ imgTiltShift = \alpha \times imagemOriginal + \beta \times imagemBorrada $$</p>

<p>A função em C++ criada para representar essa expressão é mostrada a seguir:</p>
<div class="highlight">
  <pre>
    <code class="language-" data-lang="">void updateScene() {
    Mat outputImagemBorrada, outputImagemOriginal;
    image1.convertTo(outputImagemOriginal, CV_32FC3);
    image2.convertTo(outputImagemBorrada, CV_32FC3);
    multiply(outputImagemOriginal, alpha, outputImagemOriginal);
    multiply(outputImagemBorrada, beta, outputImagemBorrada);
    Mat imageTiltShift;
    add(outputImagemOriginal, outputImagemBorrada, imageTiltShift);
    imageTiltShift.convertTo(imageTiltShift, CV_8UC3);
    imshow("tiltshift", imageTiltShift);
}
</code>
  </pre>
</div>
<p>
  <img src="/assets/pdi/tiltshift/traffic_newyorkcity.jpg" alt="Imagem Nova york sem tilttshift" />
</p>

<p>Resultado:</p>

<p>
  <img src="/assets/pdi/tiltshift/traffic_tiltshift.png" alt="Imagem Nova york com tilttshift" />
</p>

<p>O código completo pode ser baixado por <a href="/assets/codes-copyright/tiltshift.cpp">aqui</a>. Alguns outros
 resultados obtidos são apresentados a seguir:</p>

<p><img src="/assets/pdi/tiltshift/manhatan_tiltshift.png" alt="Manhatan Tilt shift" />
<img src="/assets/pdi/tiltshift/rocinha_tiltshift.png" alt="Rocinha Tiltshift" />
<img src="/assets/pdi/tiltshift/newyork_tiltshift.png" alt="New York Tiltshift" /></p>

<h3 id="topico-1-8">Segunda Unidade</h3>

<h4 id="topico-1-8-1">Filtragem no Domínio da Frequência</h4>

<p>Neste exercício, é solicitado a implementação do <a href="https://en.wikipedia.org/wiki/Homomorphic_filtering">Fitro Homomórfico</a> para melhorar imagens com iluminação regular.
Para isso, utilizou-se a imagem a seguir como base para tratamento do filtro homomórfico. </p>

<p>
  <img src="/assets/pdi/biel.png" alt="Biel" />
</p>

<p>Para auxílio da aplicação das transformadas de Fourier direta e inversa, foram utilizados os métodos de <em>dft</em> e <em>idft</em>
já implementados no OpenCV. Os passos utilizados para a aplicação do filtro foram os seguintes:</p>

<ul>
<li>Realiza-se a aplicação da Transformada de Fourier sobre a matriz de pixels da imagem, obtendo-se assim Z(x,y)</li>
<li>Realiza-se a troca de quadrantes da imagem, apresentada no exercício "Manipulando pixels em uma imagem". </li>
<li>Constrói-se a matriz do filtro H(x,y), utilizando a seguinte fórmula:</li>
</ul>

<p>$$ H(u, v) = (\gamma_H  - \gamma_L)(1 - e^{\frac{-cD^2(u,v)}{D_o^2}}) + \gamma_L $$</p>

<ul>
<li>Após isso, realiza-se uma multiplicação ponto a ponto da matriz H(u, v) por Z(x, y), obtendo-se G(x, y);</li>
<li>Realiza-se então novamente a troca dos quadrantes mas agora para a nova imagem G(x,y);</li>
<li>E, por fim, realiza-se a transformada inversa de Fourier sobre a iamgem G(x, y) e a imagem resultante é a imagem obtida.</li>
</ul>

<p>Foi tentado incrementar o filtro homomórfico aplicando a função logarítmica antes da transformada (tratando-se o caso de log(0)),
e aplicando a exponencial ao valor de saída como é mostrado <a href="http://academic.mu.edu/phys/matthysd/web226/L0219.htm">nesse link</a>. No entanto, não obteve-se um
resultado agradável e por isso não foi colocado aqui.</p>

<p>Parte do código utilizado para a implementação do filtro homomófico é apresetando a seguir:</p>
<div class="highlight">
  <pre>
    <code class="language-" data-lang="">void calcHomomorphicFilter() {
    Mat filter = Mat(padded.size(), CV_32FC2, Scalar(0));
    Mat tmp = Mat(dft_M, dft_N, CV_32F);

    for (int i = 0; i &lt; dft_M; i++) {
        for (int j = 0; j &lt; dft_N; j++) {
            float d2 = pow(i - dft_M/2.0, 2) + pow(j - dft_N/2.0, 2);
            float exp = - (d2/pow(d0, 2));
            float valor = (yh - yl)*(1 - expf(exp) ) + yl;
            tmp.at&lt;float&gt; (i,j) = valor;
        }
    }

    Mat comps[] = {tmp, tmp};
    merge(comps, 2, filter);

    Mat dftClone = imageDft.clone();

    mulSpectrums(dftClone,filter,dftClone,0);

    deslocaDFT(dftClone);

    idft(dftClone, dftClone);

    vector&lt;Mat&gt; planos;

    split (dftClone, planos);

    normalize(planos[0], planos[0], 0, 1, CV_MINMAX);

    ...
}
</code>
  </pre>
</div>
<p>O código completo pode ser encontrado <a href="/assets/pdi/filtroHomomorfico.cpp">aqui</a>.</p>

<p>A imagem tratada através do filtro homomórfico é mostrada a seguir:</p>

<p>
  <img src="/assets/pdi/filtroHomomorfico.png" alt="Filtro Homomorfico" />
</p>

<h4 id="topico-1-8-2">Canny e a arte do pontilhismo</h4>

<p>Este exercício solicita que seja implementado o programa <em>cannypoints.cpp</em>. A ideia é que seja utilizado
as bordas detectadas através do algoritmo de Canny para melhorar a qualidade da imagem pontilhista.</p>

<p>A estratégia aqui adotada foi desenhar círculos nos contornos detectados pela algoritmo através
das funções <em>circle()</em> e <em>findContours()</em> do OpenCV. O resultado da imagem é uma figura 
pontilhista com mais detalhes nas regiões próximas a borda.</p>

<p>A imagem original utilizada é apresentada a seguir:</p>

<p>
  <img src="/assets/pdi/eiffel.png" alt="Torre Eiffel" />
</p>

<p>Com o algoritmo desenvolvido, aplicou-se o efeito na imagem acima e o resultado sem a utilização do
 algoritmo de Canny é mostrado a seguir:</p>

<p>
  <img src="/assets/pdi/testeSemCanny.png" alt="Resultado Sem Canny" />
</p>

<p>Uma vez aplicado o efeito, com a estratégia citada acima, o resultado da imagem foi o seguinte:</p>

<p>
  <img src="/assets/pdi/resultadoComCanny.png" alt="Resultado com Canny" />
</p>

<p>Foi realizado também um teste com a geração da imagem em formato colorido, o resultado está representado 
na imagem abaixo:</p>

<p>
  <img src="/assets/pdi/pontilhismoSemCanny.png" alt="Pontilhismo sem canny" />
</p>

<p>O algoritmo que gerou estas imagens pode ser baixado por <a href="/assets/pdi/cannypoints.cpp">aqui</a>. O código foi implementado
 usando as <em>trackbars</em> disponibilizados pelo OpenCV e a parte mais
significativa do código é mostrado a seguir:</p>
<div class="highlight">
  <pre>
    <code class="language-" data-lang="">//Referente ao desenho do pontilhismo usando as bordas de canny como referênca. 
vector&lt;vector&lt;Point&gt;&gt; contornos;
  vector&lt;Vec4i&gt; hierarquia;
  findContours(border, contornos, hierarquia, CV_RETR_TREE, CV_CHAIN_APPROX_NONE);
  for (int i = 0; i &lt; contornos.size(); i++){
    for (int j = 0; j &lt; contornos[i].size(); j++) {
      uchar cor = image.at&lt;uchar&gt;(contornos[i][j].y, contornos[i][j].x);
      circle(points, cv::Point(contornos[i][j].x, contornos[i][j].y),
      1,
      CV_RGB(cor, cor, cor),
      -1,
      CV_AA);
    }
  }
</code>
  </pre>
</div>
<div class="tags">
    <small>
        <i class="fa fa-tags"></i>
        floodfill, seedfill, histograma, equalização, motion detector, processamento digital, opencv, imagens, UFRN, Agostinho Brito, tiltshift, blur filter, DCA
    </small>
</div>
</span>

      </div>
      <div class="anuncio">
    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <!-- Dudevictor github -->
    <ins class="adsbygoogle"
         style="display:block"
         data-ad-client="ca-pub-9976909752880073"
         data-ad-slot="9516328345"
         data-ad-format="auto"></ins>
    <script>
        (adsbygoogle = window.adsbygoogle || []).push({});
    </script>
    
</div>
      <div class="content-panel feedback">
        Gostou desta página? Compartilhe ou deixe um comentário abaixo!<br />
        
        <div class="share">
          <!-- Go to www.addthis.com/dashboard to customize your tools -->
          <div class="addthis_sharing_toolbox"></div>
        </div>
        
      </div>

      
      <div class="content-panel comments">
        <div id="disqus_thread">
          <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
          <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
        </div>
      </div>
      


      <div class="content-panel related col-md-12">
        
        
        
        
        <div class="related-header">
          <a href=" /projects/programacao-concorrente/
          ">Páginas Sugeridas</a>
        </div>
        <div class="title">
          <a href=" /projects/programacao-concorrente/
          ">Programação Concorrente e Distribuída</a>

        </div>
        <div class="excerpt">
          
          <p>Resolução da lista de exercícios do livro <em>An Introduction to Parallel Programming</em></p>

          
          <br/><a href=" /projects/programacao-concorrente/
          ">Continue Lendo</a>
        </div>
        
      </div>

    </div>

    <div class="anuncio-lateral pull-right">
    <div class="conteudo-anuncio-lateral">
        
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <!-- Lateral Responsivo -->
        <ins class="adsbygoogle"
             style="display:block"
             data-ad-client="ca-pub-9976909752880073"
             data-ad-slot="1336169546"
             data-ad-format="auto"></ins>
        <script>
            (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
        
    </div>
</div>

  </div>



</div>


<script type="text/javascript">
/* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
function disqus_config() { this.experiment.enable_scroll_container = true; }
var disqus_shortname = "dudevictorgithub"; // required: replace example with your forum shortname
/* * * DON'T EDIT BELOW THIS LINE * * */
(function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>


      </div>
    </div>

    <div class="footer clearfix">
    <div class="col-md-6">
        Copyright © 2016 by <a href="http://github.com/dudevictor">dudevictor</a>.
        All rights reserved.<br>Theme by <a href="https://twitter.com/_JacobTomlinson">Jacob
        Tomlinson</a>
    </div>
    <div class="col-md-6">
        &lt;/&gt; on <a href="https://github.com/dudevictor/dudevictor.github.io">Github</a> &nbsp;<i class="fa fa-github-alt"></i>
    </div>
</div>

<script src="//code.jquery.com/jquery-1.11.0.min.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/jquery.mmenu.all.min.js"></script>
<script src="/js/highlight.min.js"></script>

<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&locale=br" type="text/javascript"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  "HTML-CSS": { linebreaks: { automatic: true, width: "90% container" } },
  "SVG": { linebreaks: { automatic: true, width: "90% container" } }
});
</script>


<script>hljs.initHighlightingOnLoad();</script>
<script type="text/javascript">
   $(document).ready(function() {
      var API = $("#my-menu").mmenu({
          counters		: true,
          dividers		: {
              fixed 			: true
          },
          navbar 			: {
              title			: ''
          },
          navbars			: [
              {
                  position	: 'top',
                  content : ['<span>José Victor Alves de Souza</span>']
              },
              {
                  position	: 'top'
              },
              {
                  position	: 'bottom',
                  content 	: ["<div class='language-links'><a class='active' href='/projects/processamento-digital-imagens/'>pt-BR</a><a  href='/en/projects/processamento-digital-imagens/'>en</a></div>"]
              }
          ]
      }).data( 'mmenu' );

       API.bind( "closed", function() {
          $(".menu-button").show();
          $("#at4-share, #at-share-dock").each(function() {
              $(this).removeClass("hide");
          });
      });

       $(".menu-button").click(function (e) {
           e.preventDefault();
           API.open();
           $(".menu-button").hide();
           $("#at4-share, #at-share-dock").each(function () {
               $(this).removeClass("at4-show").addClass("hide");
           });

       });
   });
</script>

    </body>
</html>
